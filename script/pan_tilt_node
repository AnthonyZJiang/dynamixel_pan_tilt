#!/usr/bin/env python3

import sys, tty, termios
fd = sys.stdin.fileno()
old_settings = termios.tcgetattr(fd)
def getch():
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch

from dynamixel_sdk import *
import rospy
from dynamixel_pan_tilt.msg import PanTilt


class DynamixelPanTiltError(Exception):
    pass

class HardwareError(Exception):
    pass

def sign(x):
    return 1 if x >= 0 else -1

class ServoController:
    add_operating_mode = 11
    add_torque_enable = 64
    add_goal_position = 116
    add_present_position = 132
    add_goal_velocity = 104
    add_profile_velocity = 112
    add_profile_acceleration = 108
    add_moving_velocity = 32
    add_cw_angle_limit = 6
    add_ccw_angle_limit = 8
    add_val_operating_mode_velocity_control = 1
    add_val_operating_mode_position_control = 3
    
    id = 0
    protocol_version = 2.0
    position_home = 2048
    position_max = 3300
    position_min = 796
    goal_tolerance = 2
    moving_velocity = 100
    acceleration_profile = 10

    def __init__(self):
        self.port_handler = None
        self.packet_handler = None
        self.goal_position = None
        self.goal_velocity = None
        self.is_torque_enabled = False
        self.is_position_control = False

    def setup(self, port_handler, packet_handler):
        self.port_handler = port_handler
        self.packet_handler = packet_handler

    def reset(self):
        self.__setPositionControl()
        self.home()

    def setPosition(self, position):
        if not self.is_position_control:
            self.__setPositionControl()
        if not self.is_torque_enabled:
            self.__setTorqueEnable(True)
        if self.isSameGoalPosition(position):
            return
        self.goal_position = position
        self.__setGoalPosition(position)

    def incrementPosition(self, increment):
        if not self.is_position_control:
            self.__setPositionControl()
        if not self.is_torque_enabled:
            self.__setTorqueEnable(True)
        present = self.__getPresentPosition()
        goal = self.constrainGoalPosition(present + increment)
        # print("ID: %d, Present: %d, Goal: %d" % (self.id, present, goal))
        if self.isSameGoalPosition(goal):
            return
        self.goal_position = goal
        return self.__setGoalPosition(goal)

    def setVelocity(self, velocity):
        if self.is_position_control:
            self.__setVelocityControl()
        if not self.is_torque_enabled:
            self.__setTorqueEnable(True)
        if self.isSameGoalVelocity(velocity):
            return
        self.goal_velocity = velocity
        self.__setGoalVelocity(velocity)

    def constrainGoalPosition(self, goal):
        return max(self.position_min, min(self.position_max, goal))

    def isSameGoalPosition(self, new_goal):
        if self.goal_position is None:
            return False
        return abs(new_goal - self.goal_position) < self.goal_tolerance
    
    def isSameGoalVelocity(self, new_velocity):
        if self.goal_velocity is None:
            return False
        return abs(new_velocity - self.goal_velocity) < self.goal_tolerance

    def stop(self):
        return self.__setTorqueEnable(False)

    def home(self):
        return self.setPosition(self.position_home)

    def __writeByteTxRx(self, byteSize, address, value):
        if byteSize == 1:
            result, error = self.packet_handler.write1ByteTxRx(self.port_handler, self.id, address, value)
        elif byteSize == 2:
            result, error = self.packet_handler.write2ByteTxRx(self.port_handler, self.id, address, value)
        elif byteSize == 4:
            result, error = self.packet_handler.write4ByteTxRx(self.port_handler, self.id, address, value)
        print("DXL_ID - %d : Wrote %d to %d" % (self.id, value, address))
        if result != COMM_SUCCESS:
            raise IOError("Failed while setting address %d to %d: %s" % (address, value, self.packet_handler.getTxRxResult(result)))
        elif error != 0:
            raise HardwareError("Errors while setting address %d to %d: %s" % (address, value, self.packet_handler.getRxPacketError(error)))
    
    def __readByteTxRx(self, byteSize, address):
        if byteSize == 1:
            value, result, error = self.packet_handler.read1ByteTxRx(self.port_handler, self.id, address)
        elif byteSize == 2:
            value, result, error = self.packet_handler.read2ByteTxRx(self.port_handler, self.id, address)
        if result != COMM_SUCCESS:
            raise IOError("Failed while reading address %d: %s" % (address, self.packet_handler.getTxRxResult(result)))
        if error != 0:
            raise HardwareError("Errors while reading address %d: %s" % (address, self.packet_handler.getRxPacketError(error)))
        return value

    def __getPresentPosition(self):
        return self.__readByteTxRx(2, self.add_present_position)

    def __setGoalPosition(self, goal_position):
        if self.protocol_version == 1.0:
            self.__writeByteTxRx(2, self.add_goal_position, goal_position)
        else:
            self.__writeByteTxRx(4, self.add_goal_position, goal_position)

    def __setMovingVelocity(self, goal_velocity):
        self.__writeByteTxRx(2, self.add_moving_velocity, goal_velocity)

    def __setGoalVelocity(self, goal_velocity):
        self.__writeByteTxRx(4, self.add_goal_velocity, goal_velocity)

    def __setTorqueEnable(self, enable):
        self.__writeByteTxRx(1, self.add_torque_enable, 1 if enable else 0)
        self.is_torque_enabled = enable
    
    def __setPositionControlVelocityProfile(self):
        if self.protocol_version == 1.0:
            self.__setMovingVelocity(self.moving_velocity)
        else:
            self.__writeByteTxRx(4, self.add_profile_velocity, self.moving_velocity)
            self.__writeByteTxRx(4, self.add_profile_acceleration, self.acceleration_profile)
    
    def __setPositionControl(self):
        self.__setTorqueEnable(False)
        if self.protocol_version == 1.0:
            self.__writeByteTxRx(2, self.add_cw_angle_limit, self.position_min)
            self.__writeByteTxRx(2, self.add_ccw_angle_limit, self.position_max)
        else:
            self.__writeByteTxRx(1, self.add_operating_mode, self.add_val_operating_mode_position_control)
        self.__setPositionControlVelocityProfile()
        self.is_position_control = True
        self.goal_velocity = None
        self.__setTorqueEnable(True)

    def __setVelocityControl(self):
        if self.protocol_version == 1.0:
            raise NotImplementedError("Velocity control not supported in protocol 1.0")
        self.__setTorqueEnable(False)
        self.__writeByteTxRx(1, self.add_operating_mode, self.add_val_operating_mode_velocity_control)
        self.is_position_control = False
        self.goal_position = None
        self.__setTorqueEnable(True)

class PanTiltController:
    devicename = None
    baudrate = None
    protocol_version = None

    def __init__(self):
        self.is_setup = False
        self.is_connected = False
        self.pan_servo = ServoController()
        self.tilt_servo = ServoController()

    def __del__(self):
        self.disconnect()

    def setup(self):
        self.port_handler = PortHandler(self.devicename)
        self.port_handler.setBaudRate(self.baudrate)
        self.packet_handler = PacketHandler(self.protocol_version)
        self.pan_servo.setup(self.port_handler, self.packet_handler)
        self.tilt_servo.setup(self.port_handler, self.packet_handler)
        self.is_setup = True

    def connect(self):
        if not self.is_setup:
            self.setup()
        if not self.__openPort():
            return False
        self.pan_servo.reset()
        self.tilt_servo.reset()
        self.is_connected = True
        return True

    def disconnect(self):
        try:
            self.stop()
            self.__closePort()
        except:
            pass
        self.is_connected = False

    def isReady(self):
        return self.is_setup and self.is_connected

    def home(self):
        if not self.isReady():
            raise IOError("Not connected")
        self.pan_servo.home()
        self.tilt_servo.home()

    def setIncrement(self, pan, tilt):
        if not self.isReady():
            raise IOError("Not connected")
        self.pan_servo.incrementPosition(pan)
        self.tilt_servo.incrementPosition(tilt)

    def setPosition(self, pan, tilt):
        if not self.isReady():
            raise IOError("Not connected")
        self.pan_servo.setPosition(pan)
        self.tilt_servo.setPosition(tilt)

    def setVelocity(self, pan, tilt):
        if not self.isReady():
            raise IOError("Not connected")
        self.pan_servo.setVelocity(pan)
        self.tilt_servo.setVelocity(tilt)

    def stop(self):
        if not self.isReady():
            raise IOError("Not connected")
        self.tilt_servo.stop()
        self.pan_servo.stop()

    def __openPort(self):
        if self.port_handler.openPort():
            return self.port_handler.setBaudRate(self.baudrate)
        else:
            return False
     
    def __closePort(self):
        self.port_handler.closePort()

class PanTiltNode:
    servo_param_names = ['id', 'position_home', 'position_max', 'position_min', 'position_tolerance', 'moving_velocity', 'acceleration_profile']
    address_names = ['operating_mode', 'torque_enable', 'goal_position', 'present_position', 'profile_velocity', 'profile_acceleration', 'moving_velocity', 'cw_angle_limit', 'ccw_angle_limit']
    address_value_names = ['operating_mode_position_control']

    def __init__(self):
        self.controller = PanTiltController()
        self.setParams()
        self.controller.connect()
        self.pos_sub = rospy.Subscriber("/pan_tilt_position", PanTilt, self.posSubCallback, queue_size=1)
        self.inc_sub = rospy.Subscriber("/pan_tilt_increment", PanTilt, self.incSubCallback, queue_size=1)
        self.vel_sub = rospy.Subscriber("/pan_tilt_velocity", PanTilt, self.velSubCallback, queue_size=1)

    def setParams(self):
        if not rospy.has_param("dynamixel_pan_tilt"):
            rospy.logfatal("Cannot find dynamixel_pan_tilt configuration")
            raise DynamixelPanTiltError("no config")
        config = rospy.get_param("dynamixel_pan_tilt")
        self.controller.devicename = config.get("device_name")
        self.controller.baudrate = config.get("dxl_baudrate")
        self.controller.protocol_version = config.get("dxl_protocol_version")
        if "servo_common" in config:
            self.__set_servo_params(config["servo_common"], True, True)            
        if "pan_servo" in config:
            self.__set_servo_params(config["pan_servo"], True, False)
        if "tilt_servo" in config:
            self.__set_servo_params(config["tilt_servo"], False, True)

    def __set_servo_params(self, config, set_pan, set_tilt):
        for name in self.servo_param_names:
            if name in config:
                if set_pan:
                    setattr(self.controller.pan_servo, name, config[name])
                if set_tilt:
                    setattr(self.controller.tilt_servo, name, config[name])
        if 'address' in config:
            address = config['address']
            for name in self.address_names:
                if name in address:
                    if set_pan:
                        setattr(self.controller.pan_servo, 'add_' + name, address[name])
                    if set_tilt:
                        setattr(self.controller.tilt_servo, 'add_' + name, address[name])
        if 'address_value' in config:
            address_value = config['address_value']
            for name in self.address_value_names:
                if name in address_value:
                    if set_pan:
                        setattr(self.controller.pan_servo, 'add_val_' + name, address_value[name])
                    if set_tilt:
                        setattr(self.controller.tilt_servo, 'add_val_' + name, address_value[name])

    def posSubCallback(self, pos):
        # print("Setting position to %d, %d" % (pos.pan_val, pos.tilt_val))
        self.controller.setPosition(int(pos.pan_val), int(pos.tilt_val))

    def incSubCallback(self, pos):
        # print("Incrementing position by %d, %d" % (pos.pan_val, pos.tilt_val))
        self.controller.setIncrement(int(pos.pan_val), int(pos.tilt_val))

    def velSubCallback(self, pos):
        # print("Setting velocity to %d, %d" % (pos.pan_val, pos.tilt_val))
        self.controller.setVelocity(int(pos.pan_val), int(pos.tilt_val))

if __name__ == "__main__":
    rospy.init_node('pan_tilt_node')
    pan_tilt_node = PanTiltNode()
    rospy.spin()